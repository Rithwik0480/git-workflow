"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAccountAddressFromIdentifier = exports.getAccountIdentifierFromAddress = exports.checkIdentifier = exports.uriToIdentifier = exports.hashToUri = exports.hashToIdentifier = void 0;
const util_crypto_1 = require("@polkadot/util-crypto");
const util_1 = require("@polkadot/util");
const types_1 = require("@cord.network/types");
const types_2 = require("@cord.network/types");
const defaults = {
    allowedDecodedLengths: [1, 2, 4, 8, 32, 33],
    allowedEncodedLengths: [3, 4, 6, 10, 35, 36, 37, 38],
};
const IDFR_PREFIX = (0, util_1.stringToU8a)('CRDIDFR');
function pphash(key) {
    return (0, util_crypto_1.blake2AsU8a)((0, util_1.u8aConcat)(IDFR_PREFIX, key), 512);
}
function checkAddressChecksum(decoded) {
    const iDfrLength = decoded[0] & 0b0100_0000 ? 2 : 1;
    const iDfrDecoded = iDfrLength === 1
        ? decoded[0]
        : ((decoded[0] & 0b0011_1111) << 2) |
            (decoded[1] >> 6) |
            ((decoded[1] & 0b0011_1111) << 8);
    // 32/33 bytes + 2 bytes checksum + prefix
    const isContentHash = [34 + iDfrLength, 35 + iDfrLength].includes(decoded.length);
    const length = decoded.length - (isContentHash ? 2 : 1);
    // calculate the hash and do the checksum byte checks
    const hash = pphash(decoded.subarray(0, length));
    const isValid = (decoded[0] & 0b1000_0000) === 0 &&
        ![46, 47].includes(decoded[0]) &&
        (isContentHash
            ? decoded[decoded.length - 2] === hash[0] &&
                decoded[decoded.length - 1] === hash[1]
            : decoded[decoded.length - 1] === hash[0]);
    return [isValid, length, iDfrLength, iDfrDecoded];
}
function encodeIdentifier(key, iDPrefix) {
    (0, util_1.assert)(key, 'Invalid key string passed');
    // decode it, this means we can re-encode an identifier
    const u8a = (0, util_1.u8aToU8a)(key);
    (0, util_1.assert)(iDPrefix >= 0 && iDPrefix <= 16383 && ![46, 47].includes(iDPrefix), 'Out of range IdentifierFormat specified');
    (0, util_1.assert)(defaults.allowedDecodedLengths.includes(u8a.length), () => `Expected a valid key to convert, with length ${defaults.allowedDecodedLengths.join(', ')}`);
    const input = (0, util_1.u8aConcat)(iDPrefix < 64
        ? [iDPrefix]
        : [
            ((iDPrefix & 0b0000_0000_1111_1100) >> 2) | 0b0100_0000,
            (iDPrefix >> 8) | ((iDPrefix & 0b0000_0000_0000_0011) << 6),
        ], u8a);
    return (0, util_crypto_1.base58Encode)((0, util_1.u8aConcat)(input, pphash(input).subarray(0, [32, 33].includes(u8a.length) ? 2 : 1)));
}
function hashToIdentifier(identifier, iDPrefix) {
    (0, util_1.assert)(identifier, 'Invalid key string passed');
    const id = encodeIdentifier(identifier, iDPrefix);
    return id;
}
exports.hashToIdentifier = hashToIdentifier;
function hashToUri(identifier, iDPrefix, prefix) {
    (0, util_1.assert)(identifier, 'Invalid key string passed');
    const id = encodeIdentifier(identifier, iDPrefix);
    return `${prefix}${id}`;
}
exports.hashToUri = hashToUri;
function uriToIdentifier(identifier) {
    (0, util_1.assert)(identifier, 'Invalid key string passed');
    if (identifier.startsWith(types_1.SCHEMA_PREFIX)) {
        return identifier.split(types_1.SCHEMA_PREFIX).join('');
    }
    else if (identifier.startsWith(types_1.REGISTRY_PREFIX)) {
        return identifier.split(types_1.REGISTRY_PREFIX).join('');
    }
    else if (identifier.startsWith(types_1.STREAM_PREFIX)) {
        return identifier.split(types_1.STREAM_PREFIX).join('');
    }
    else if (identifier.startsWith(types_1.SCORE_PREFIX)) {
        return identifier.split(types_1.SCORE_PREFIX).join('');
    }
    else if (identifier.startsWith(types_2.ACCOUNT_IDENTIFIER_PREFIX)) {
        return identifier.split(types_2.ACCOUNT_IDENTIFIER_PREFIX).join('');
    }
    else if (identifier.startsWith(types_1.AUTHORIZATION_PREFIX)) {
        return identifier.split(types_1.AUTHORIZATION_PREFIX).join('');
    }
    else {
        throw new Error(`Invalid Identifier ${identifier}`);
    }
}
exports.uriToIdentifier = uriToIdentifier;
/**
 * @name checkIdentifier
 * @summary Validates an identifier.
 * @description
 * From the provided input, validate that the address is a valid input.
 */
function checkIdentifier(address) {
    let decoded;
    try {
        decoded = (0, util_crypto_1.base58Decode)(address);
    }
    catch (error) {
        return [false, error.message];
    }
    const [isValid, , , idfrDecoded] = checkAddressChecksum(decoded);
    if (idfrDecoded !== types_2.REGISTRY_IDENT ||
        idfrDecoded !== types_2.SCHEMA_IDENT ||
        idfrDecoded !== types_2.STREAM_IDENT ||
        idfrDecoded !== types_2.SCORE_IDENTIFIER ||
        idfrDecoded !== types_2.AUTHORIZATION_IDENT) {
        return [false, `Prefix mismatch, found ${idfrDecoded}`];
    }
    else if (!defaults.allowedEncodedLengths.includes(decoded.length)) {
        return [false, 'Invalid decoded idenfirer length'];
    }
    return [isValid, isValid ? null : 'Invalid decoded identifier checksum'];
}
exports.checkIdentifier = checkIdentifier;
/**
 * Creates Account Identifier from Fetches Account Address.
 *
 * @param address Account address to derive it's identifier.
 *
 * @returns The Address identifier from the Account Address.
 */
function getAccountIdentifierFromAddress(address) {
    return address.startsWith(types_2.ACCOUNT_IDENTIFIER_PREFIX)
        ? address
        : types_2.ACCOUNT_IDENTIFIER_PREFIX + address;
}
exports.getAccountIdentifierFromAddress = getAccountIdentifierFromAddress;
/**
 * Fetches Account Address from Identifier.
 *
 * @param address Account identifier to derive it's address from.
 * @throws When the identifier is not prefixed with the defined ACCOUNT_IDENTIFIER_PREFIX.
 * @throws [[ERROR_INVALID_ID_PREFIX]].
 *
 * @returns The Address derived from the Account Identifier.
 */
function getAccountAddressFromIdentifier(address) {
    return address.split(types_2.ACCOUNT_IDENTIFIER_PREFIX).join('');
}
exports.getAccountAddressFromIdentifier = getAccountAddressFromIdentifier;
