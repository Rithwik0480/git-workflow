"use strict";
/**
 * Registry.
 *
 * @packageDocumentation
 * @module Registry
 * @preferred
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.uriToIdentifier = exports.toChain = exports.getAuthorizationDetails = exports.fetchAuthorizationDetailsfromChain = exports.verifyAuthorization = exports.verifyStored = exports.isIRegistry = exports.getAuthorizationIdentifier = exports.fromRegistryProperties = exports.getUriForRegistry = exports.verifyRegistryDataStructure = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@cord.network/utils");
const types_1 = require("@cord.network/types");
const config_1 = require("@cord.network/config");
const Did = tslib_1.__importStar(require("@cord.network/did"));
const util_crypto_1 = require("@polkadot/util-crypto");
/**
 *  Checks whether the input meets all the required criteria of an [[IRegistry]] object.
 *  Throws on invalid input.
 *
 * @param input The potentially only partial [[IRegistry]].
 *
 */
function verifyRegistryDataStructure(input) {
    if (!input.meta.schema) {
        throw new utils_1.SDKErrors.SchemaMissingError();
    }
    if (!input.meta.creator) {
        throw new utils_1.SDKErrors.CreatorMissingError();
    }
    if (!input.meta.digest) {
        throw new utils_1.SDKErrors.DataStructureError('registry hash not provided');
    }
    if (!input.details) {
        throw new utils_1.SDKErrors.ContentMissingError();
    }
    else {
        Object.entries(input.details).forEach(([key, value]) => {
            if (!key ||
                typeof key !== 'string' ||
                !['string', 'number', 'boolean', 'object'].includes(typeof value)) {
                throw new utils_1.SDKErrors.RegistryInputMalformedError();
            }
        });
    }
    utils_1.DataUtils.verifyIsHex(input.meta.digest, 256);
}
exports.verifyRegistryDataStructure = verifyRegistryDataStructure;
/**
 * Calculates the registry Id by hashing it.
 *
 * @param registry  Registry for which to create the id.
 * @returns Registry id uri.
 */
function getUriForRegistry(serializedRegistry, creator) {
    const api = config_1.ConfigService.get('api');
    const scaleEncodedRegistry = api
        .createType('Bytes', serializedRegistry)
        .toU8a();
    const scaleEncodedCreator = api
        .createType('AccountId', Did.toChain(creator))
        .toU8a();
    const digest = (0, util_crypto_1.blake2AsHex)(Uint8Array.from([...scaleEncodedRegistry, ...scaleEncodedCreator]));
    return utils_1.Identifier.hashToUri(digest, types_1.REGISTRY_IDENT, types_1.REGISTRY_PREFIX);
}
exports.getUriForRegistry = getUriForRegistry;
/**
   * Creates a new [[Registry]] from an [[IRegistryType]].
 
   *
   * @param space The request from which the [[Registry]] should be generated.
   * @param controller The identity of the [[Registry]] creator.
   * @returns An instance of [[Registry]].
   */
function fromRegistryProperties(registryProps) {
    const registryType = utils_1.jsonabc.sortObj({
        ...registryProps.details,
    });
    const encodedRegistry = utils_1.Crypto.encodeObjectAsStr(registryType);
    const registryHash = utils_1.Crypto.hashStr(encodedRegistry);
    const registryId = getUriForRegistry(encodedRegistry, registryProps.creator);
    const registryDetails = {
        identifier: registryId,
        registryHash: registryHash,
        details: encodedRegistry,
    };
    const registryMeta = {
        digest: registryHash,
        schema: registryProps.schema || null,
        creator: registryProps.creator,
        active: true,
    };
    const registry = {
        identifier: registryId,
        details: registryDetails.details,
        meta: registryMeta,
    };
    verifyRegistryDataStructure(registry);
    return registry;
}
exports.fromRegistryProperties = fromRegistryProperties;
function getAuthorizationIdentifier(registry, authority, creator) {
    const api = config_1.ConfigService.get('api');
    const scaleEncodedRegistry = api
        .createType('Bytes', uriToIdentifier(registry))
        .toU8a();
    const scaleEncodedAuthority = api
        .createType('AccountId', Did.toChain(authority))
        .toU8a();
    const scaleEncodedCreator = api
        .createType('AccountId', Did.toChain(creator))
        .toU8a();
    const digest = (0, util_crypto_1.blake2AsHex)(Uint8Array.from([
        ...scaleEncodedRegistry,
        ...scaleEncodedAuthority,
        ...scaleEncodedCreator,
    ]));
    const authorizationId = utils_1.Identifier.hashToUri(digest, types_1.AUTHORIZATION_IDENT, types_1.AUTHORIZATION_PREFIX);
    return authorizationId;
}
exports.getAuthorizationIdentifier = getAuthorizationIdentifier;
/**
 *  Custom Type Guard to determine input being of type ISpace using the SpaceUtils errorCheck.
 *
 * @param input The potentially only partial ISpace.
 * @returns Boolean whether input is of type ISpace.
 */
function isIRegistry(input) {
    try {
        verifyRegistryDataStructure(input);
    }
    catch (error) {
        return false;
    }
    return true;
}
exports.isIRegistry = isIRegistry;
/**
 * Checks on the CORD blockchain whether a Registry is anchored.
 *
 * @param registry Registry data.
 */
async function verifyStored(registry) {
    const api = config_1.ConfigService.get('api');
    const identifier = utils_1.Identifier.uriToIdentifier(registry.identifier);
    const encoded = await api.query.registry.registries(identifier);
    if (encoded.isNone)
        throw new utils_1.SDKErrors.RegistryIdentifierMissingError(`Registry with identifier ${identifier} is not registered on chain`);
}
exports.verifyStored = verifyStored;
/**
 * Checks on the CORD blockchain whether a schema is registered.
 *
 * @param schema Schema data.
 */
async function verifyAuthorization(auth) {
    const api = config_1.ConfigService.get('api');
    const identifier = utils_1.Identifier.uriToIdentifier(auth);
    const encoded = await api.query.registry.authorizations(identifier);
    if (encoded.isNone)
        throw new utils_1.SDKErrors.AuthorizationIdMissingError(`Authorization with identifier ${identifier} is not registered on chain`);
}
exports.verifyAuthorization = verifyAuthorization;
/**
 * Checks on the CORD blockchain whether a Registry is anchored.
 *
 * @param auth authorization URI.
 */
async function fetchAuthorizationDetailsfromChain(auth) {
    const api = config_1.ConfigService.get('api');
    const authorizationId = utils_1.Identifier.uriToIdentifier(auth);
    const registryAuthoriation = await api.query.registry.authorizations(authorizationId);
    if (registryAuthoriation.isNone) {
        throw new utils_1.SDKErrors.AuthorizationIdentifierMissingError(`Registry Authorization with identifier ${authorizationId} is not registered on chain`);
    }
    else {
        return registryAuthoriation;
    }
}
exports.fetchAuthorizationDetailsfromChain = fetchAuthorizationDetailsfromChain;
function getAuthorizationDetails(encodedEntry) {
    const decodedEntry = encodedEntry.unwrap();
    const authorizationDetails = {
        delegate: Did.fromChain(decodedEntry.delegate),
        schema: utils_1.DecoderUtils.hexToString(decodedEntry.schema.toString()),
    };
    return authorizationDetails;
}
exports.getAuthorizationDetails = getAuthorizationDetails;
/**
 * Encodes the provided Schema for use in `api.tx.schema.add()`.
 *
 * @param schema The Schema to write on the blockchain.
 * @returns Encoded Schema.
 */
function toChain(details) {
    return utils_1.Crypto.encodeObjectAsStr(details);
}
exports.toChain = toChain;
function uriToIdentifier(registryId) {
    return utils_1.Identifier.uriToIdentifier(registryId);
}
exports.uriToIdentifier = uriToIdentifier;
