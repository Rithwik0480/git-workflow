"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPresentation = exports.getHash = exports.isPresentation = exports.isIDocument = exports.verifyPresentation = exports.verifyDocument = exports.fromContent = exports.getUriForStream = exports.verifySignature = exports.verifyAgainstSchema = exports.verifyAuthorization = exports.verifyDataStructure = exports.verifyDataIntegrity = exports.verifyDocumentHash = exports.makeSigningData = exports.removeContentProperties = exports.calculateDocumentHash = void 0;
const tslib_1 = require("tslib");
const did_1 = require("@cord.network/did");
const utils_1 = require("@cord.network/utils");
const Content = tslib_1.__importStar(require("../content/index.js"));
const index_js_1 = require("../content/index.js");
const Schema_js_1 = require("../schema/Schema.js");
const types_1 = require("@cord.network/types");
const utils_2 = require("@cord.network/utils");
const Did = tslib_1.__importStar(require("@cord.network/did"));
const util_crypto_1 = require("@polkadot/util-crypto");
const config_1 = require("@cord.network/config");
function getHashRoot(leaves) {
    const result = utils_1.Crypto.u8aConcat(...leaves);
    return utils_1.Crypto.hash(result);
}
function getHashLeaves(contentHashes, evidenceIds, createdAt, validUntil) {
    const result = contentHashes.map((item) => utils_1.Crypto.coToUInt8(item));
    if (evidenceIds) {
        evidenceIds.forEach((evidence) => {
            result.push(utils_1.Crypto.coToUInt8(evidence.identifier));
        });
    }
    if (createdAt) {
        result.push(utils_1.Crypto.coToUInt8(createdAt));
    }
    if (validUntil) {
        result.push(utils_1.Crypto.coToUInt8(validUntil));
    }
    return result;
}
/**
 * Calculates the root hash of the document.
 *
 * @param document The document object.
 * @returns The document hash.
 */
function calculateDocumentHash(document) {
    const hashes = getHashLeaves(document.contentHashes || [], document.evidenceIds || [], document.createdAt || '', document.validUntil || '');
    const root = getHashRoot(hashes);
    return utils_1.Crypto.u8aToHex(root);
}
exports.calculateDocumentHash = calculateDocumentHash;
/**
 * Removes [[Content] properties from the [[Document]] object, provides anonymity and security when building the [[createPresentation]] method.
 *
 * @param document - The document object to remove properties from.
 * @param properties - Properties to remove from the [[Content]] object.
 * @returns A cloned Document with removed properties.
 */
function removeContentProperties(document, properties) {
    const presentation = 
    // clone the credential because properties will be deleted later.
    // TODO: find a nice way to clone stuff
    JSON.parse(JSON.stringify(document));
    properties.forEach((key) => {
        delete presentation.content.contents[key];
    });
    presentation.contentNonceMap = (0, index_js_1.hashContents)(presentation.content, {
        nonces: presentation.contentNonceMap,
    }).nonceMap;
    return presentation;
}
exports.removeContentProperties = removeContentProperties;
/**
 * Prepares credential data for signing.
 *
 * @param input - The Stream to prepare the data for.
 * @param challenge - An optional challenge to be included in the signing process.
 * @returns The prepared signing data as Uint8Array.
 */
function makeSigningData(input, challenge) {
    return new Uint8Array([
        ...utils_1.Crypto.coToUInt8(input.documentHash),
        ...utils_1.Crypto.coToUInt8(challenge),
    ]);
}
exports.makeSigningData = makeSigningData;
function verifyDocumentHash(input) {
    if (input.documentHash !== calculateDocumentHash(input))
        throw new utils_1.SDKErrors.RootHashUnverifiableError();
}
exports.verifyDocumentHash = verifyDocumentHash;
/**
 * Verifies the data of the [[ContentStream]] object; used to check that the data was not tampered with, by checking the data against hashes.
 *
 * @param input - The [[Stream]] for which to verify data.
 */
function verifyDataIntegrity(input) {
    // check document hash
    verifyDocumentHash(input);
    // verify properties against selective disclosure proof
    Content.verifyDisclosedAttributes(input.content, {
        nonces: input.contentNonceMap,
        hashes: input.contentHashes,
    });
    // check evidences
    input.evidenceIds.forEach(verifyDataIntegrity);
}
exports.verifyDataIntegrity = verifyDataIntegrity;
/**
 *  Checks whether the input meets all the required criteria of an IDocument object.
 *  Throws on invalid input.
 *
 * @param input - A potentially only partial [[IDocument]].
 *
 */
function verifyDataStructure(input) {
    if (!('content' in input)) {
        throw new utils_1.SDKErrors.ContentMissingError();
    }
    else {
        Content.verifyDataStructure(input.content);
    }
    if (!input.content.holder) {
        throw new utils_1.SDKErrors.HolderMissingError();
    }
    if (!Array.isArray(input.evidenceIds)) {
        throw new utils_1.SDKErrors.EvidenceMissingError();
    }
    if (!('contentNonceMap' in input)) {
        throw new utils_1.SDKErrors.ContentNonceMapMissingError();
    }
    if (typeof input.contentNonceMap !== 'object')
        throw new utils_1.SDKErrors.ContentNonceMapMalformedError();
    Object.entries(input.contentNonceMap).forEach(([digest, nonce]) => {
        utils_1.DataUtils.verifyIsHex(digest, 256);
        if (!digest || typeof nonce !== 'string' || !nonce)
            throw new utils_1.SDKErrors.ContentNonceMapMalformedError();
    });
    if (!('contentHashes' in input)) {
        throw new utils_1.SDKErrors.DataStructureError('content hashes not provided');
    }
}
exports.verifyDataStructure = verifyDataStructure;
function verifyAuthorization(input, authorizationDetails) {
    if (input.issuer !== authorizationDetails.delegate) {
        throw new utils_1.SDKErrors.IssuerMismatchError();
    }
    if (input.schemaId !== authorizationDetails.schema) {
        throw new utils_1.SDKErrors.SchemaMismatchError();
    }
}
exports.verifyAuthorization = verifyAuthorization;
/**
 *  Checks the [[Document]] with a given [[SchemaType]] to check if the claim meets the [[schema]] structure.
 *
 * @param document A [[Document]] object of an anchored content used for verification.
 * @param schema A [[Schema]] to verify the [[Content]] structure.
 */
function verifyAgainstSchema(document, schema) {
    verifyDataStructure(document);
    (0, Schema_js_1.verifyContentAganistSchema)(document.content.contents, schema);
}
exports.verifyAgainstSchema = verifyAgainstSchema;
/**
 * Verifies the signature of the [[IDocumentPresentation]].
 * the signature over the presentation **must** be generated with the DID in order for the verification to be successful.
 *
 * @param input - The [[IPresentation]].
 * @param verificationOpts Additional verification options.
 * @param verificationOpts.didResolveKey - The function used to resolve the claimer's key. Defaults to [[resolveKey]].
 * @param verificationOpts.challenge - The expected value of the challenge. Verification will fail in case of a mismatch.
 */
async function verifySignature(input, { challenge, didResolveKey = did_1.resolveKey, } = {}) {
    // verify Holder Signature
    const { holderSignature } = input;
    if (challenge && challenge !== holderSignature.challenge)
        throw new utils_1.SDKErrors.SignatureUnverifiableError('Challenge differs from expected');
    const signingData = makeSigningData(input, holderSignature.challenge);
    await (0, did_1.verifyDidSignature)({
        ...(0, did_1.signatureFromJson)(holderSignature),
        message: signingData,
        // check if credential owner matches signer
        expectedSigner: input.content.holder,
        expectedVerificationMethod: 'authentication',
        didResolveKey,
    });
    // verify Issuer Signature
    const { issuerSignature } = input;
    const uint8DocumentHash = new Uint8Array([
        ...utils_1.Crypto.coToUInt8(input.documentHash),
    ]);
    await (0, did_1.verifyDidSignature)({
        ...(0, did_1.signatureFromJson)(issuerSignature),
        message: uint8DocumentHash,
        // check if credential issuer matches signer
        expectedSigner: input.content.issuer,
        expectedVerificationMethod: 'authentication',
        didResolveKey,
    });
}
exports.verifySignature = verifySignature;
/**
 * Calculates the stream Id by hashing it.
 *
 * @param stream  Stream for which to create the id.
 * @returns Stream id uri.
 */
function getUriForStream(streamDigest, registry, creator) {
    const api = config_1.ConfigService.get('api');
    const scaleEncodedDigest = api.createType('H256', streamDigest).toU8a();
    const scaleEncodedRegistry = api.createType('Bytes', registry).toU8a();
    const scaleEncodedCreator = api
        .createType('AccountId', Did.toChain(creator))
        .toU8a();
    const digest = (0, util_crypto_1.blake2AsHex)(Uint8Array.from([
        ...scaleEncodedDigest,
        ...scaleEncodedRegistry,
        ...scaleEncodedCreator,
    ]));
    return utils_2.Identifier.hashToUri(digest, types_1.STREAM_IDENT, types_1.STREAM_PREFIX);
}
exports.getUriForStream = getUriForStream;
/**
 * Builds a new  [[IDocument]] object, from a complete set of required parameters.
 *
 * @param content An `IContent` object to build the document for.
 * @param option Container for different options that can be passed to this method.
 * @param authorization The authrization id of the Issuer, which should be used in anchoring the document.
 * @param registry Identifier of the registry this document is linked to.
 * @param option.evidenceIds Array of [[Document]] objects the Issuer include as evidenceIds.
 * @returns A new [[IDocument]] object.
 */
async function fromContent({ content, authorization, registry, signCallback, 
// evidenceIds,
options = {}, }) {
    const { evidenceIds, expiresAt, templates = [], labels } = options;
    const { hashes: contentHashes, nonceMap: contentNonceMap } = Content.hashContents(content);
    const issuanceDate = new Date();
    const issuanceDateString = issuanceDate.toISOString();
    const expiryDateString = expiresAt ? expiresAt.toISOString() : 'Infinity';
    const metaData = {
        templates: templates || [],
        labels: labels || [],
    };
    const documentHash = calculateDocumentHash({
        evidenceIds,
        contentHashes,
        createdAt: issuanceDateString,
        validUntil: expiryDateString,
    });
    const registryIdentifier = utils_2.Identifier.uriToIdentifier(registry);
    const streamId = getUriForStream(documentHash, registryIdentifier, content.issuer);
    const uint8Hash = new Uint8Array([...utils_1.Crypto.coToUInt8(documentHash)]);
    const issuerSignature = await signCallback({
        data: uint8Hash,
        did: content.issuer,
        keyRelationship: 'authentication',
    });
    const document = {
        identifier: streamId,
        content,
        contentHashes,
        contentNonceMap,
        evidenceIds: evidenceIds || [],
        authorization: authorization,
        registry: registry,
        createdAt: issuanceDateString,
        validUntil: expiryDateString,
        documentHash,
        issuerSignature: (0, did_1.signatureToJson)(issuerSignature),
        metadata: metaData,
    };
    verifyDataStructure(document);
    return document;
}
exports.fromContent = fromContent;
/**
 * Verifies data structure & data integrity of a credential object.
 *
 * @param document - The object to check.
 * @param options - Additional parameter for more verification steps.
 * @param options.schema - Schema to be checked against.
 */
async function verifyDocument(document, { schema } = {}) {
    verifyDataStructure(document);
    verifyDataIntegrity(document);
    if (schema) {
        verifyAgainstSchema(document, schema);
    }
}
exports.verifyDocument = verifyDocument;
/**
 * Verifies data structure, data integrity and the holder's signature of a document presentation.
 *
 * Upon presentation of a document, a verifier would call this function.
 *
 * @param presentation - The object to check.
 * @param options - Additional parameter for more verification steps.
 * @param options.schema - Schema which the included document should be checked against.
 * @param options.challenge -  The expected value of the challenge. Verification will fail in case of a mismatch.
 * @param options.didResolveKey - The function used to resolve the holders's key. Defaults to [[resolveKey]].
 */
async function verifyPresentation(presentation, { schema, challenge, didResolveKey = did_1.resolveKey } = {}) {
    await verifyDocument(presentation, { schema });
    await verifySignature(presentation, {
        challenge,
        didResolveKey,
    });
}
exports.verifyPresentation = verifyPresentation;
/**
 * Type Guard to determine input being of type [[IDocument]].
 *
 * @param input - A potentially only partial [[IDocument]].
 *
 * @returns  Boolean whether input is of type IDocument.
 */
function isIDocument(input) {
    try {
        verifyDataStructure(input);
    }
    catch (error) {
        return false;
    }
    return true;
}
exports.isIDocument = isIDocument;
/**
 * Type Guard to determine input being of type [[IDocumentPresentation]].
 *
 * @param input - An [[IDocument]], [[IDocumentPresentation]], or other object.
 *
 * @returns  Boolean whether input is of type IDocumentPresentation.
 */
function isPresentation(input) {
    return (isIDocument(input) &&
        (0, did_1.isDidSignature)(input.holderSignature));
}
exports.isPresentation = isPresentation;
/**
 * Gets the hash of the document.
 *
 * @param document - The document to get the hash from.
 * @returns The hash of the credential.
 */
function getHash(document) {
    return document.documentHash;
}
exports.getHash = getHash;
/**
 * Gets names of the document's attributes.
 *
 * @param document The document.
 * @returns The set of names.
 */
function getAttributes(document) {
    return new Set(Object.keys(document.content.contents));
}
/**
 * Creates a public presentation which can be sent to a verifier.
 * This presentation is signed.
 *
 * @param presentationOptions The additional options to use upon presentation generation.
 * @param presentationOptions.document The document to create the presentation for.
 * @param presentationOptions.signCallback The callback to sign the presentation.
 * @param presentationOptions.selectedAttributes All properties of the credential which have been requested by the verifier and therefore must be publicly presented.
 * @param presentationOptions.challenge Challenge which will be part of the presentation signature.
 * If not specified, all attributes are shown. If set to an empty array, we hide all attributes inside the claim for the presentation.
 * @returns A deep copy of the Credential with selected attributes.
 */
async function createPresentation({ document, signCallback, selectedAttributes, challenge, }) {
    // filter attributes that are not in requested attributes
    const excludedClaimProperties = selectedAttributes
        ? Array.from(getAttributes(document)).filter((property) => !selectedAttributes.includes(property))
        : [];
    // remove these attributes
    const presentation = removeContentProperties(document, excludedClaimProperties);
    const signature = await signCallback({
        data: makeSigningData(presentation, challenge),
        did: document.content.holder,
        keyRelationship: 'authentication',
    });
    return {
        ...presentation,
        holderSignature: {
            ...(0, did_1.signatureToJson)(signature),
            ...(challenge && { challenge }),
        },
    };
}
exports.createPresentation = createPresentation;
