"use strict";
/**
 * Schema.
 *
 * * A Schema is a description of the [[Stream]] data structure, based on [JSON Schema](http://json-schema.org/).
 * * Schemas are published and stored by the issuer.
 * * Permissioned users can use a Schema to create a new [[Stream]].
 *
 * @packageDocumentation
 * @module Schema
 * @preferred
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isISchema = exports.fromProperties = exports.verifySchemaMetadata = exports.verifyContentAgainstNestedSchemas = exports.verifyDataStructure = exports.verifySchemaStructure = exports.verifyStored = exports.verifyContentAganistSchema = exports.verifyObjectAgainstSchema = exports.getUriForSchema = exports.getHashForSchema = exports.serializeForHash = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@cord.network/utils");
const types_1 = require("@cord.network/types");
const Schema_types_js_1 = require("./Schema.types.js");
const config_1 = require("@cord.network/config");
const Did = tslib_1.__importStar(require("@cord.network/did"));
const util_crypto_1 = require("@polkadot/util-crypto");
/**
 * Utility for (re)creating Schema hashes. Sorts the schema and strips the $id property (which contains the Schema hash) before stringifying.
 *
 * @param schema The Schema (with or without $id).
 * @returns A deterministic JSON serialization of a Schema, omitting the $id property.
 */
function serializeForHash(schema) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { $id, ...schemaWithoutId } = schema;
    return utils_1.Crypto.encodeObjectAsStr(schemaWithoutId);
}
exports.serializeForHash = serializeForHash;
/**
 * Calculates the Schema hash from schema properties.
 *
 * @param schema The Schema (with or without $id).
 * @returns Hash as hex string.
 */
function getHashForSchema(schema) {
    const serializedSchema = serializeForHash(schema);
    return utils_1.Crypto.hashStr(serializedSchema);
}
exports.getHashForSchema = getHashForSchema;
/**
 * Calculates the schema $id by hashing it.
 *
 * @param schema  Schema for which to create the id.
 * @returns Schema id uri.
 */
function getUriForSchema(schema, creator) {
    const api = config_1.ConfigService.get('api');
    const serializedSchema = serializeForHash(schema);
    const scaleEncodedSchema = api
        .createType('Bytes', serializedSchema)
        .toU8a();
    const scaleEncodedCreator = api
        .createType('AccountId', Did.toChain(creator))
        .toU8a();
    const digest = (0, util_crypto_1.blake2AsHex)(Uint8Array.from([...scaleEncodedSchema, ...scaleEncodedCreator]));
    return utils_1.Identifier.hashToUri(digest, types_1.SCHEMA_IDENT, types_1.SCHEMA_PREFIX);
}
exports.getUriForSchema = getUriForSchema;
/**
 * Verifies data against schema or schema against metaschema.
 *
 * @param object Data to be verified against schema.
 * @param schema Schema to verify against.
 * @param messages Optional empty array. If passed, this receives all verification errors.
 * @returns Whether or not verification was successful.
 */
function verifyObjectAgainstSchema(object, schema, messages, referencedSchemas) {
    const validator = new utils_1.JsonSchema.Validator(schema, '7', false);
    if (referencedSchemas) {
        referencedSchemas.forEach((i) => validator.addSchema(i));
    }
    const { valid, errors } = validator.validate(object);
    if (valid === true)
        return;
    if (messages) {
        errors.forEach((error) => {
            messages.push(error.error);
        });
    }
    throw new utils_1.SDKErrors.ObjectUnverifiableError('JSON schema verification failed for object', { cause: errors });
}
exports.verifyObjectAgainstSchema = verifyObjectAgainstSchema;
/**
 *  Verifies the structure of the provided IContent['contents'] with ISchema.
 *
 * @param contents IContent['contents'] to be verified against the schema.
 * @param schema ISchema to be verified against the [SchemaModel].
 * @param messages An array, which will be filled by schema errors.
 *
 */
function verifyContentAganistSchema(contents, schema, messages) {
    verifyObjectAgainstSchema(schema, Schema_types_js_1.SchemaModel, messages);
    verifyObjectAgainstSchema(contents, schema, messages);
}
exports.verifyContentAganistSchema = verifyContentAganistSchema;
/**
 * Checks on the CORD blockchain whether a schema is registered.
 *
 * @param schema Schema data.
 */
async function verifyStored(schema) {
    const api = config_1.ConfigService.get('api');
    const identifier = utils_1.Identifier.uriToIdentifier(schema.$id);
    const encoded = await api.query.schema.schemas(identifier);
    if (encoded.isNone)
        throw new utils_1.SDKErrors.SchemaIdMissingError(`Schema with identifier ${identifier} is not registered on chain`);
}
exports.verifyStored = verifyStored;
/**
 * Checks whether the input meets all the required criteria of an ISchema object.
 * Throws on invalid input.
 *
 * @param input The ISchema object.
 */
function verifySchemaStructure(input, creator) {
    verifyObjectAgainstSchema(input, Schema_types_js_1.SchemaModel);
    const uriFromSchema = getUriForSchema(input, creator);
    if (uriFromSchema !== input.$id) {
        throw new utils_1.SDKErrors.SchemaIdMismatchError(uriFromSchema, input.$id);
    }
}
exports.verifySchemaStructure = verifySchemaStructure;
/**
 * Checks whether the schema input meets all the required criteria of an ISchema object.
 * Throws on invalid input.
 *
 * @param input The ISchem object.
 */
function verifyDataStructure(input) {
    verifyObjectAgainstSchema(input, Schema_types_js_1.SchemaModel);
}
exports.verifyDataStructure = verifyDataStructure;
/**
 * Validates an array of [[CType]]s against a [[Claim]].
 *
 * @param cType - A [[CType]] that has nested [[CType]]s inside.
 * @param nestedCTypes - An array of [[CType]] schemas.
 * @param claimContents - The contents of a [[Claim]] to be validated.
 * @param messages - Optional empty array. If passed, this receives all verification errors.
 */
function verifyContentAgainstNestedSchemas(schema, nestedSchemas, contents, messages) {
    verifyObjectAgainstSchema(schema, Schema_types_js_1.SchemaModel, messages);
    verifyObjectAgainstSchema(contents, schema, messages, nestedSchemas);
}
exports.verifyContentAgainstNestedSchemas = verifyContentAgainstNestedSchemas;
/**
 * Checks a SchemaMetadata object.
 *
 * @param metadata [[ISchemaMetadata]] that is to be instantiated.
 */
function verifySchemaMetadata(metadata) {
    verifyObjectAgainstSchema(metadata, Schema_types_js_1.MetadataModel);
}
exports.verifySchemaMetadata = verifySchemaMetadata;
/**
 *  Creates a new [[ISchema]] object.
 *
 * @param title The new Schema's title as a string.
 * @param properties Key-value pairs describing the admissible atomic claims for a credential with this Schema. The value of each property is a json-schema (for example `{ "type": "number" }`) used to validate that property.
 * @param description A description of the Schema.
 * @param metadata Metadata for the Schema.
 * @returns A Schema object.
 */
function fromProperties(title, properties, creator) {
    const schema = {
        properties,
        title,
        $schema: Schema_types_js_1.SchemaModelV1.$id,
        type: 'object',
    };
    schema.additionalProperties = false;
    const schemaType = utils_1.jsonabc.sortObj({
        ...schema,
        $id: getUriForSchema(schema, creator),
    });
    verifySchemaStructure(schemaType, creator);
    return schemaType;
}
exports.fromProperties = fromProperties;
/**
 *  Custom Type Guard to determine input being of type ISchema.
 *
 * @param input The potentially only partial ISchema.
 * @returns Boolean whether input is of type ISchema.
 */
function isISchema(input) {
    try {
        verifyDataStructure(input);
    }
    catch (error) {
        return false;
    }
    return true;
}
exports.isISchema = isISchema;
