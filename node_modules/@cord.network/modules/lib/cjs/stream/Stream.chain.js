"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromChain = exports.idToChain = exports.toChain = void 0;
const tslib_1 = require("tslib");
const config_1 = require("@cord.network/config");
const Did = tslib_1.__importStar(require("@cord.network/did"));
const utils_1 = require("@cord.network/utils");
const log = config_1.ConfigService.LoggingFactory.getLogger('Stream');
/**
 * Encodes the provided stream for use in `api.tx.stream.create()`.
 *
 * @param stream The Stream to translate for the blockchain.
 * @returns Encoded Stream.
 */
function toChain(content) {
    const chainStream = {
        streamHash: content.streamHash,
        schema: utils_1.Identifier.uriToIdentifier(content.schema),
    };
    return chainStream;
}
exports.toChain = toChain;
/**
 * Encodes the provided Stream['$id'] for use in `api.query.schema.schemas()`.
 *
 * @param schemaId The Schema id to translate for the blockchain.
 * @returns Encoded Schema id.
 */
function idToChain(streamId) {
    return utils_1.Identifier.uriToIdentifier(streamId);
}
exports.idToChain = idToChain;
/**
 * Decodes the stream returned by `api.query.stream.streams()`.
 *
 * @param encoded Raw stream data from blockchain.
 * @param identifier The stream identifier.
 * @returns The stream.
 */
function fromChain(encoded, identifier) {
    const chainStream = encoded.unwrap();
    const stream = {
        identifier,
        streamHash: chainStream.digest.toHex(),
        issuer: Did.fromChain(chainStream.creator),
        schema: utils_1.DecoderUtils.hexToString(chainStream.schema.toString()),
        registry: utils_1.DecoderUtils.hexToString(chainStream.registry.toString()) || null,
        revoked: chainStream.revoked.valueOf(),
    };
    log.info(`Decoded stream: ${JSON.stringify(stream)}`);
    return stream;
}
exports.fromChain = fromChain;
