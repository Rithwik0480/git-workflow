/// <reference types="bn.js" />
import type { ApiPromise } from '@polkadot/api';
import type { TxWithEvent } from '@polkadot/api-derive/types';
import type { GenericCall, GenericExtrinsic } from '@polkadot/types';
import type { Call, Extrinsic } from '@polkadot/types/interfaces';
import type { BN } from '@polkadot/util';
/**
 * Checks wheather the provided extrinsic or call represents a batch.
 *
 * @param api The [[ApiPromise]].
 * @param extrinsic The input [[Extrinsic]] or [[Call]].
 *
 * @returns True if it's a batch, false otherwise.
 */
export declare function isBatch(api: ApiPromise, extrinsic: Extrinsic | Call): extrinsic is GenericExtrinsic<typeof api.tx.utility.batch.args | typeof api.tx.utility.batchAll.args | typeof api.tx.utility.forceBatch.args> | GenericCall<typeof api.tx.utility.batch.args | typeof api.tx.utility.batchAll.args | typeof api.tx.utility.forceBatch.args>;
/**
 * Flatten all calls into a single array following a DFS approach.
 *
 * For example, given the calls [[N1, N2], [N3, [N4, N5], N6]], the final list will look like [N1, N2, N3, N4, N5, N6].
 *
 * @param api The [[ApiPromise]] object.
 * @param call The [[Call]] which can potentially contain nested calls.
 *
 * @returns A list of [[Call]] nested according to the rules above.
 */
export declare function flattenCalls(api: ApiPromise, call: Call): Call[];
/**
 * Retrieve the last extrinsic from a block that matches the provided filter.
 *
 * The function ignores failed extrinsics and, if multiple extrinsics from the block match the provided filter, it only takes the last one.
 *
 * @param api The [[ApiPromise]] object.
 * @param blockNumber The number of the block to parse.
 * @param filter The filter to apply to the transactions in the block.
 *
 * @returns The last extrinsic in the block matching the filter, or null if no extrinsic is found.
 */
export declare function retrieveExtrinsicFromBlock(api: ApiPromise, blockNumber: BN, filter: (tx: TxWithEvent) => boolean): Promise<Extrinsic | null>;
