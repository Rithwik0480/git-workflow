/**
 * Checks wheather the provided extrinsic or call represents a batch.
 *
 * @param api The [[ApiPromise]].
 * @param extrinsic The input [[Extrinsic]] or [[Call]].
 *
 * @returns True if it's a batch, false otherwise.
 */
export function isBatch(api, extrinsic) {
    return (api.tx.utility.batch.is(extrinsic) ||
        api.tx.utility.batchAll.is(extrinsic) ||
        api.tx.utility.forceBatch.is(extrinsic));
}
/**
 * Flatten all calls into a single array following a DFS approach.
 *
 * For example, given the calls [[N1, N2], [N3, [N4, N5], N6]], the final list will look like [N1, N2, N3, N4, N5, N6].
 *
 * @param api The [[ApiPromise]] object.
 * @param call The [[Call]] which can potentially contain nested calls.
 *
 * @returns A list of [[Call]] nested according to the rules above.
 */
export function flattenCalls(api, call) {
    if (isBatch(api, call)) {
        // Inductive case
        return call.args[0].flatMap((c) => flattenCalls(api, c));
    }
    // Base case
    return [call];
}
/**
 * Retrieve the last extrinsic from a block that matches the provided filter.
 *
 * The function ignores failed extrinsics and, if multiple extrinsics from the block match the provided filter, it only takes the last one.
 *
 * @param api The [[ApiPromise]] object.
 * @param blockNumber The number of the block to parse.
 * @param filter The filter to apply to the transactions in the block.
 *
 * @returns The last extrinsic in the block matching the filter, or null if no extrinsic is found.
 */
export async function retrieveExtrinsicFromBlock(api, blockNumber, filter) {
    const { extrinsics } = await api.derive.chain.getBlockByNumber(blockNumber);
    const successfulExtrinsics = extrinsics.filter(({ dispatchError }) => !dispatchError);
    const extrinsicLastOccurrence = successfulExtrinsics.reverse().find(filter);
    return extrinsicLastOccurrence?.extrinsic ?? null;
}
