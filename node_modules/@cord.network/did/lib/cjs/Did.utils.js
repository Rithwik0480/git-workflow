"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDidUriFromKey = exports.getDidUri = exports.getAddressByKey = exports.validateUri = exports.isSameSubject = exports.parse = void 0;
const util_crypto_1 = require("@polkadot/util-crypto");
const utils_1 = require("@cord.network/utils");
// The latest version for DIDs.
const DID_LATEST_VERSION = 1;
// NOTICE: The following regex patterns must be kept in sync with DidUri type in @cord.network/types
// Matches the following DIDs
// - did:cord:<cord_address>
// - did:cord:<cord_address>#<fragment>
const CORD_DID_REGEX = /^did:cord:(?<address>3[1-9a-km-zA-HJ-NP-Z]{47})(?<fragment>#[^#\n]+)?$/;
/**
 * Parses a CORD DID uri and returns the information contained within in a structured form.
 *
 * @param didUri A CORD DID uri as a string.
 * @returns Object containing information extracted from the DID uri.
 */
function parse(didUri) {
    let matches = CORD_DID_REGEX.exec(didUri)?.groups;
    if (matches) {
        const { version: versionString, fragment } = matches;
        const address = matches.address;
        const version = versionString
            ? parseInt(versionString, 10)
            : DID_LATEST_VERSION;
        return {
            did: didUri.replace(fragment || '', ''),
            version,
            type: 'full',
            address,
            fragment: fragment === '#' ? undefined : fragment,
        };
    }
    throw new utils_1.SDKErrors.InvalidDidFormatError(didUri);
}
exports.parse = parse;
/**
 * Returns true if both didA and didB refer to the same DID subject, i.e., whether they have the same identifier as specified in the method spec.
 *
 * @param didA A CORD DID uri as a string.
 * @param didB A second CORD DID uri as a string.
 * @returns Whether didA and didB refer to the same DID subject.
 */
function isSameSubject(didA, didB) {
    return parse(didA).address === parse(didB).address;
}
exports.isSameSubject = isSameSubject;
/**
 * Checks that a string (or other input) is a valid CORD DID uri with or without a URI fragment.
 * Throws otherwise.
 *
 * @param input Arbitrary input.
 * @param expectType `ResourceUri` if the URI is expected to have a fragment (following '#'), `Did` if it is expected not to have one. Default allows both.
 */
function validateUri(input, expectType) {
    if (typeof input !== 'string') {
        throw new TypeError(`DID string expected, got ${typeof input}`);
    }
    const { address, fragment } = parse(input);
    if (fragment &&
        (expectType === 'Did' ||
            // for backwards compatibility with previous implementations, `false` maps to `Did` while `true` maps to `undefined`.
            (typeof expectType === 'boolean' && expectType === false))) {
        throw new utils_1.SDKErrors.DidError('Expected a CORD DidUri but got a DidResourceUri (containing a #fragment)');
    }
    if (!fragment && expectType === 'ResourceUri') {
        throw new utils_1.SDKErrors.DidError('Expected a CORD DidResourceUri (containing a #fragment) but got a DidUri');
    }
    utils_1.DataUtils.verifyCordAddress(address);
}
exports.validateUri = validateUri;
/**
 * Internal: derive the address part of the DID when it is created from authentication key.
 *
 * @param input The authentication key.
 * @param input.publicKey The public key.
 * @param input.type The type of the key.
 * @returns The expected address of the DID.
 */
function getAddressByKey({ publicKey, type, }) {
    if (type === 'ed25519' || type === 'sr25519') {
        return (0, util_crypto_1.encodeAddress)(publicKey, utils_1.ss58Format);
    }
    // Otherwise it’s ecdsa.
    // Taken from https://github.com/polkadot-js/common/blob/master/packages/keyring/src/pair/index.ts#L44
    const address = publicKey.length > 32 ? (0, util_crypto_1.blake2AsU8a)(publicKey) : publicKey;
    return (0, util_crypto_1.encodeAddress)(address, utils_1.ss58Format);
}
exports.getAddressByKey = getAddressByKey;
/**
 * Builds the URI an accountswill have after it’s stored on the blockchain.
 *
 * @param didOrAddress The URI of the account. Internally it’s used with the DID "address" as well.
 * @param version The version of the DID URI to use.
 * @returns The expected DID URI.
 */
function getDidUri(didOrAddress) {
    const address = utils_1.DataUtils.isCordAddress(didOrAddress)
        ? didOrAddress
        : parse(didOrAddress).address;
    return `did:cord:${address}`;
}
exports.getDidUri = getDidUri;
/**
 * Builds the URI of a DID if it is created with the authentication key provided.
 *
 * @param key The key that will be used as DID authentication key.
 * @returns The expected DID URI.
 */
function getDidUriFromKey(key) {
    const address = getAddressByKey(key);
    return getDidUri(address);
}
exports.getDidUriFromKey = getDidUriFromKey;
