import { u8aToString } from '@polkadot/util';
import { Crypto, ss58Format } from '@cord.network/utils';
import { getDidUri } from './Did.utils.js';
function fromChain(encoded) {
    return getDidUri(Crypto.encodeAddress(encoded, ss58Format));
}
function didPublicKeyDetailsFromChain(keyId, keyDetails) {
    const key = keyDetails.key.isPublicEncryptionKey
        ? keyDetails.key.asPublicEncryptionKey
        : keyDetails.key.asPublicVerificationKey;
    return {
        id: `#${keyId.toHex()}`,
        type: key.type.toLowerCase(),
        publicKey: key.value.toU8a(),
    };
}
function resourceIdToChain(id) {
    return id.replace(/^#/, '');
}
function documentFromChain(encoded) {
    const { publicKeys, authenticationKey, assertionKey, delegationKey, keyAgreementKeys, lastTxCounter, } = encoded;
    const keys = [...publicKeys.entries()]
        .map(([keyId, keyDetails]) => didPublicKeyDetailsFromChain(keyId, keyDetails))
        .reduce((res, key) => {
        res[resourceIdToChain(key.id)] = key;
        return res;
    }, {});
    const authentication = keys[authenticationKey.toHex()];
    const didRecord = {
        authentication: [authentication],
        lastTxCounter: lastTxCounter.toBn(),
    };
    if (assertionKey.isSome) {
        const key = keys[assertionKey.unwrap().toHex()];
        didRecord.assertionMethod = [key];
    }
    if (delegationKey.isSome) {
        const key = keys[delegationKey.unwrap().toHex()];
        didRecord.capabilityDelegation = [key];
    }
    const keyAgreementKeyIds = [...keyAgreementKeys.values()].map((keyId) => keyId.toHex());
    if (keyAgreementKeyIds.length > 0) {
        didRecord.keyAgreement = keyAgreementKeyIds.map((id) => keys[id]);
    }
    return didRecord;
}
function serviceFromChain(encoded) {
    const { id, serviceTypes, urls } = encoded;
    return {
        id: `#${u8aToString(id)}`,
        type: serviceTypes.map(u8aToString),
        serviceEndpoint: urls.map(u8aToString),
    };
}
function servicesFromChain(encoded) {
    return encoded.map((encodedValue) => serviceFromChain(encodedValue));
}
/**
 * Decodes DID and DidName linked to the provided account.
 *
 * @param encoded The data returned by `api.call.did.query()`, and `api.call.did.queryByDidName()`.

 * @returns The DID, and DidName.
 */
export function linkedInfoFromChain(encoded) {
    const { identifier, name, serviceEndpoints, details } = encoded.unwrap();
    const didRec = documentFromChain(details);
    const did = {
        uri: fromChain(identifier),
        authentication: didRec.authentication,
        assertionMethod: didRec.assertionMethod,
        capabilityDelegation: didRec.capabilityDelegation,
        keyAgreement: didRec.keyAgreement,
    };
    const service = servicesFromChain(serviceEndpoints);
    if (service.length > 0) {
        did.service = service;
    }
    const didName = name.isNone ? undefined : name.unwrap().toHuman();
    return {
        document: did,
        didName,
    };
}
